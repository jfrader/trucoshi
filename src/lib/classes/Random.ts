import { RequestParams } from "lightning-accounts"
import { IRandom } from "../../types"
import forge from "node-forge"
import { AxiosResponse } from "axios"

const rnd = Rng()

export const Random = () => {
  const random: IRandom = {
    secret: rnd.generateServerSeed(),
    clients: [],
    bitcoinHash: "",
    bitcoinHeight: 0,
    nonce: 0,
    async getLatestBitcoinBlock(fn) {
      const { hash, height } = await rnd.getBitcoinLatestBlockHash(fn)
      random.bitcoinHash = hash
      random.bitcoinHeight = height
    },
    pick(key, max) {
      return rnd.generateInteger(
        random.clients[key],
        random.secret,
        random.bitcoinHash,
        random.nonce,
        0,
        max
      )
    },
    next() {
      random.nonce++
    },
    reveal() {
      return {
        secret: random.secret,
        clients: [...random.clients],
        bitcoinHash: random.bitcoinHash,
        bitcoinHeight: random.bitcoinHeight,
      }
    },
  }

  return random
}

export interface IRng {
  combine(client: string, server: string, bitcoinHash: string, nonce: number): string
  sha512(string: string): string
  generateServerSeed(): string
  getBitcoinLatestBlockHash(
    fn: (params?: RequestParams) => Promise<
      AxiosResponse<
        {
          hash: string
          height: number
        },
        any
      >
    >
  ): Promise<{ hash: string; height: number }>
  hexToBytes(hex: string): Uint8Array
  byteGenerator(
    clientseed: string,
    serverseed: string,
    bitcoinHash: string,
    nonce: number
  ): Uint8Array
  generateInteger(
    clientSeed: string,
    serverSeed: string,
    bitcoinHash: string,
    nonce: number,
    min: number,
    max: number
  ): number
  generateFloat(
    clientSeed: string,
    serverSeed: string,
    bitcoinHash: string,
    nonce: number,
    precision?: number
  ): number
  generateBool(clientSeed: string, serverSeed: string, bitcoinHash: string, nonce: number): boolean
  selectRandomObject<
    T extends { probability: number } = {
      probability: number
      [x: string]: any
    }
  >(
    clientSeed: string,
    serverSeed: string,
    bitcoinHash: string,
    nonce: number,
    objects: Array<T>
  ): T | null
}

function Rng(): IRng {
  return {
    /**
     * Generates a random 256 long hex hash
     *
     * @param   {string} clientSeed  - the clientSeed
     * @param   {string} serverSeed  - the serverSeed
     * @param   {string} bitcoinHash - The latest bitcoin block hash.
     * @param   {number} nonce       - the nonce
     * @returns {string} combined string
     */
    combine: (clientSeed, serverSeed, bitcoinHash, nonce: number): string => {
      if (bitcoinHash) {
        return clientSeed + serverSeed + bitcoinHash + nonce
      }

      return clientSeed + serverSeed + nonce
    },
    /**
     * Generates a sha512 hash from a string
     *
     * @param   {string} string - input string
     * @returns {string} random 256 long string
     */
    sha512: (string) => forge.md.sha512.create().update(string).digest().toHex(),

    /**
     * Generates a random 256 long hex hash
     *
     * @returns {string} random 256 long string
     */
    generateServerSeed: function () {
      return forge.util.bytesToHex(forge.random.getBytesSync(256))
    },

    /**
     * Converts a hex string to a Uint8Array of bytes.
     * @param {string} hex - The hex string to convert.
     * @returns {Uint8Array} The resulting byte array.
     */
    hexToBytes: function (hex) {
      const byteCount = hex.length / 2
      const bytes = new Uint8Array(byteCount)

      for (let i = 0; i < byteCount; i++) {
        const byteHex = hex.substring(i * 2, 2)
        bytes[i] = parseInt(byteHex, 16)
      }
      return bytes
    },
    /**
     * Generates an array of 32 random bytes using the given serverseed, clientseed, and nonce.
     *
     * @param {string} clientseed - The clientseed to use.
     * @param {string} serverseed - The serverseed to use.
     * @param {string} bitcoinHash - The latest bitcoin block hash.
     * @param {number} nonce - The nonce to use.
     * @returns {Uint8Array} - The generated bytes as a Uint8Array.
     */
    byteGenerator: function (clientseed, serverseed, bitcoinHash, nonce) {
      const preHash = this.combine(clientseed, serverseed, bitcoinHash, nonce)
      const hash = this.sha512(preHash)
      return this.hexToBytes(hash.slice(0, 64))
    },

    /**
     * Generates a random integer between min and max using the specified client seed, server seed, and nonce.
     *
     * @param {string} clientSeed - The client seed.
     * @param {string} serverSeed - The server seed.
     * @param {string} bitcoinHash - The latest bitcoin block hash.
     * @param {number} nonce - The nonce.
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @returns {number} A random integer between min and max (inclusive).
     */
    generateInteger: function (clientSeed, serverSeed, bitcoinHash, nonce, min, max) {
      const preHash = this.combine(clientSeed, serverSeed, bitcoinHash, nonce)
      const hash = this.sha512(preHash)
      const range = max - min + 1

      return (parseInt(hash.slice(0, 16), 16) % range) + min
    },

    /**
     * Generates a random float between 0 and 1 using the fairjs library.
     * @param {string} clientSeed - The client seed to use for the random number generation.
     * @param {string} serverSeed - The server seed to use for the random number generation.
     * @param {string} bitcoinHash - The latest bitcoin block hash.
     * @param {number} nonce - The nonce to use for the random number generation.
     * @param {number} [precision=2] - The number of decimal places to include in the result.
     * @returns {number} - The random float between 0 and 1.
     */
    generateFloat: function (clientSeed, serverSeed, bitcoinHash, nonce, precision = 2) {
      const bytes = this.byteGenerator(clientSeed, serverSeed, bitcoinHash, nonce)
      const float = parseFloat("0." + bytes.join(""))

      return parseFloat(float.toFixed(precision))
    },

    /**
     *  Generates a random boolean using the specified client seed, server seed, and nonce.
     *
     * @param {string} clientSeed - The client seed.
     * @param {string} serverSeed - The server seed.
     * @param {number} nonce       - The nonce.
     * @returns {float, boolean} random boolean true/false
     */
    generateBool: function (clientSeed, serverSeed, bitcoinHash: string, nonce) {
      return this.generateFloat(clientSeed, serverSeed, bitcoinHash, nonce, 10) <= 0.5
        ? true
        : false
    },

    /**
     * Selects a random object from an array of objects based on their probabilities.
     *
     * @param {string} clientSeed - The client seed.
     * @param {string} serverSeed - The server seed.
     * @param {string} bitcoinHash - The latest bitcoin block hash.
     * @param {number} nonce      - The nonce.
     * @param {Array}  objects    - An array of objects with an ID and a probability property.
     * @returns {String} The ID of the randomly selected object.
     */
    selectRandomObject: function (clientSeed, serverSeed, bitcoinHash, nonce, objects) {
      let totalProbability = 0
      for (const obj of objects) {
        totalProbability += obj.probability
      }

      const normalizedProbabilities = objects.map((obj) => obj.probability / totalProbability)

      const randomFloat = this.generateFloat(clientSeed, serverSeed, bitcoinHash, nonce, 10)

      let index = 0
      for (let i = 0; i < normalizedProbabilities.length; i++) {
        index += normalizedProbabilities[i]
        if (randomFloat < index) {
          return objects[i]
        }
      }

      // If no object is selected, return null
      return null
    },

    /**
     * Gets the latest Bitcoin block hash from the LND node
     *
     * @returns {Promise<string>} The latest Bitcoin block hash
     */
    getBitcoinLatestBlockHash: async function (fn): Promise<{ hash: string; height: number }> {
      try {
        return (await fn()).data || { hash: "", height: 0 }
      } catch (error) {
        return { hash: "", height: 0 }
      }
    },
  }
}
